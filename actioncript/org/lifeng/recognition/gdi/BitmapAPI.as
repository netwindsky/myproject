package  org.lifeng.recognition.gdi{	import flash.display.BitmapData;	import flash.filters.ColorMatrixFilter;	import flash.filters.ConvolutionFilter;	import flash.geom.Matrix;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.utils.ByteArray;

	public class BitmapAPI {		private static var TPOINTDATA:Array=[0,0,0,0,0,0,1,0,0,0, 0,0,1,0,1,0,0,0,0,0,											 1,0,1,0,1,0,0,0,1,0, 1,0,0,0,0,0,0,0,0,0,											 0,0,0,0,0,0,0,0,1,0, 0,0,1,0,1,0,1,0,0,0,											 1,0,1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,											 1,3,0,4,1,0,1,0,1,3, 0,4,1,0,1,0,0,0,0,0,											 0,0,0,0,0,0,0,0,0,0, 0,0,1,3,0,4,1,0,1,0,											 1,3,0,4,1,0,1,0,0,0, 0,0,0,0,0,0,0,0,0,0,											 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,											 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,											 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,											 0,0,0,0,0,0,0,0,1,1, 0,2,1,0,1,0,1,1,0,2,											 1,0,1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,											 1,1,0,2,1,0,1,0,1,1, 0,2,1,0,1,0]		private static  var DESTPOINT:Point=new Point(0,0);		/***		 * 		 * 扣出两个图像重合区域的原图		 * 		 * **/		public static function cutOutHasoRiginal(bitMap:BitmapData,targetBitMap:BitmapData):BitmapData		{			var returnBitmapData:BitmapData = new BitmapData(bitMap.width,bitMap.height,true,0x00000000);			for(var m:Number = 0;m<targetBitMap.width;m++)			{				for(var n:Number = 0;n<targetBitMap.height;n++)				{					var bitmapColor1:uint = bitMap.getPixel32(m,n);					var tbitmapColor1:uint = targetBitMap.getPixel32(m,n);					if(bitmapColor1 != 0)					{						returnBitmapData.setPixel32(m,n,tbitmapColor1);					}				}			}			return returnBitmapData;		}		/***		 * 与黑白对比		 * **/		public static function  cutOut2(bitMap:BitmapData,targetBitMap:BitmapData):BitmapData		{			var returnBitmapData:BitmapData = new BitmapData(bitMap.width,bitMap.height,true,0x00000000);			for(var j:Number = 0;j<bitMap.width;j++)			{				for(var i:Number = 0;i<bitMap.height;i++)				{					var bitmapColor:uint = bitMap.getPixel32(j,i);					var tbitmapColor:uint = targetBitMap.getPixel32(j,i);					if(bitmapColor!=0)					{//						trace(tbitmapColor);						//256*255*255*255 = 4294967295						if(tbitmapColor ==4294967295)						returnBitmapData.setPixel32(j,i,bitmapColor);					}				}			}			return returnBitmapData;		}		/***		 * 		 * 扣出两个图像不重合的部分		 * 		 * **/		public static function cutOut(bitMap:BitmapData,targetBitMap:BitmapData):BitmapData		{			var returnBitmapData:BitmapData = new BitmapData(bitMap.width,bitMap.height,true,0x00000000);			var bitmapPixelArr:Array = new Array();			var targetBitmapPixelArr:Array = new Array();			for(var j:Number = 0;j<bitMap.width;j++)			{				for(var i:Number = 0;i<bitMap.height;i++)				{					var bitmapColor:uint = bitMap.getPixel32(j,i);					var tbitmapColor:uint = targetBitMap.getPixel32(j,i);					var tbitmapColorpre:uint = tbitmapColor -1;					var tbitmapColorNext:uint = tbitmapColor+1;					var dvalue:uint = Math.abs(bitmapColor-tbitmapColor);					if(bitmapColor == tbitmapColor)					{						returnBitmapData.setPixel32(j,i,bitmapColor);					}					else					{						if(bitmapColor!=0)						{							trace(bitmapColor,tbitmapColor);							//returnBitmapData.setPixel32(j,i,bitmapColor);						}					}				}			}			var returnBitmapData2:BitmapData = new BitmapData(bitMap.width,bitMap.height,true,0x00000000);			for(var m:Number = 0;m<returnBitmapData.width;m++)			{				for(var n:Number = 0;n<returnBitmapData.height;n++)				{					var bitmapColor1:uint = returnBitmapData.getPixel32(m,n);										if(bitmapColor1 == 0)					{						returnBitmapData2.setPixel32(m,n,checkRound(returnBitmapData,m,n));					}				}			}			return returnBitmapData;		}		/**		 * 去除图像边缘空白区域		 * **/		public static function trim(originalBitmap:BitmapData,alphaBd:BitmapData=null):Object {//			var nowRect:Rectangle=new Rectangle(0,0,1,1);			var obj:Object = null;			//边界检测		/*	leftCheckLoop:for (var i:Number=0; i < originalBitmap.width; i++) {				for (var j:Number=0; j < originalBitmap.height; j++) {					trace(originalBitmap.getPixel32(i,j));					if (originalBitmap.getPixel32(i,j) != 0) {						nowRect.left=i;						break leftCheckLoop;					}				}			}			topCheckLoop:for (var k:Number=0; k < originalBitmap.height; k++) {				for (var q:Number=0; q < originalBitmap.width; q++) {					if (originalBitmap.getPixel32(q,k) != 0) {						nowRect.top=k;						break topCheckLoop;					}				}			}			rightCheckLoop:for (var m:Number=originalBitmap.width - 1; m >= 0; m--) {				for (var n:Number=originalBitmap.height - 1; n >= 0; n--) {					if (originalBitmap.getPixel32(m,n) != 0) {						nowRect.right=m;						break rightCheckLoop;					}				}			}			bottomCheckLoop:for (var a:Number=originalBitmap.height - 1; a >= 0; a--) {				for (var b:Number=originalBitmap.width - 1; b >= 0; b--) {					if (originalBitmap.getPixel32(b,a) != 0) {						nowRect.bottom=a;						break bottomCheckLoop;					}				}			}*/			var nowRect:Rectangle = originalBitmap.getColorBoundsRect(0xFF000000,0x00000000,false) ;			if (nowRect.width < 4 || nowRect.height < 4) {//				throw new GDIError("Invalid Bitmap Size!",1001);				return (null);			} else {				var returnBitmap:BitmapData=new BitmapData(nowRect.width,nowRect.height,true,0x00);				returnBitmap.copyPixels(originalBitmap,nowRect,DESTPOINT,null,null,true);				obj = new Object();				obj.data = returnBitmap;				obj.rect = nowRect;				return obj;			}		}		//图像二值化		public static function binary(originalBitmap:BitmapData):BitmapData {			var returnBitmap:BitmapData=new BitmapData(originalBitmap.width,originalBitmap.height,false);			returnBitmap.threshold(originalBitmap,new Rectangle(0,0,originalBitmap.width,originalBitmap.height),DESTPOINT,"<",0xAAAAAA,0xFFFFFF,0xFF0000,false);			return returnBitmap;		}		/**		 * 图像灰度化		 * **/		public static function graying(originalBitmap:BitmapData):BitmapData {			var returnBitmap:BitmapData=new BitmapData(originalBitmap.width,originalBitmap.height,false);			returnBitmap.applyFilter(originalBitmap,new Rectangle(0,0,originalBitmap.width,originalBitmap.height),DESTPOINT,new ColorMatrixFilter(new Array(0.3086,0.6094,0.0820,0,0,0.3086,0.6094,0.0820,0,0,0.3086,0.6094,0.0820,0,0,0,0,0,1,0)));			return returnBitmap;		}		/**		 * 改变图像尺寸		 * **/		public static function resize(originalBitmap:BitmapData,w:Number,h:Number):BitmapData {			var returnBitmap:BitmapData=new BitmapData(w,h,true,0xff);			returnBitmap.draw(originalBitmap,new Matrix(w / originalBitmap.width,0,0,h / originalBitmap.height,0,0),null,null,null,true);			return returnBitmap;		}		/**		 * 设置输出alpha		 * **/		public static function setAlpha(originalBitmap:BitmapData,w:Number,h:Number):BitmapData {			var returnBitmap:BitmapData=new BitmapData(w,h,true);			returnBitmap.draw(originalBitmap,new Matrix(w / originalBitmap.width,0,0,h / originalBitmap.height,0,0),null,null,null,true);			return returnBitmap;		}		//扩展边缘		public static function expand(originalBitmap:BitmapData,b:Number):BitmapData {			var returnBitmap:BitmapData=new BitmapData(originalBitmap.width+b*2,originalBitmap.height+b*2,false);			returnBitmap.copyPixels(originalBitmap,new Rectangle(0,0,originalBitmap.width,originalBitmap.height),new Point(b,b));			return returnBitmap;		}		//缩小边缘		public static function inset(originalBitmap:BitmapData,b:Number):BitmapData {			var returnBitmap:BitmapData=new BitmapData(originalBitmap.width-b*2,originalBitmap.height-b*2,false);			returnBitmap.copyPixels(originalBitmap,new Rectangle(b,b,originalBitmap.width-b,originalBitmap.height-b),DESTPOINT);			return returnBitmap;		}		//从网上搜集到的细化算法移植而来，版权归原作者所有		//该算法细化后的图像骨架是严格的1象素，再适合文字识别不过		public static function thinning(originalBitmap:BitmapData):BitmapData {			originalBitmap=expand(originalBitmap,1);			var i,j,k:Number=0;			var changed:Boolean;			var count:Number=0;			var THINNINGWIDTH:Number=originalBitmap.width;			var THINNINGHEIGHT:Number=originalBitmap.height;			var nbr,tmp1,tmp2,nbn,nbw:Number;			var ORIBMPDATA:Array=new Array(THINNINGWIDTH);			var FOTBMPDATA:Array=new Array(THINNINGWIDTH);			var SOTBMPDATA:Array=new Array(THINNINGWIDTH);			//指针			for (i=0; i < THINNINGWIDTH; i++) {				ORIBMPDATA[i]=new Array(THINNINGHEIGHT);				FOTBMPDATA[i]=new Array(THINNINGHEIGHT);				SOTBMPDATA[i]=new Array(THINNINGHEIGHT);				for (j=0; j < THINNINGHEIGHT; j++) {					FOTBMPDATA[i][j]=SOTBMPDATA[i][j]=ORIBMPDATA[i][j]=originalBitmap.getPixel(i,j) == 0?1:0;				}			}			var p1,p2,p3,p4:Array;			p1=ORIBMPDATA;			p2=FOTBMPDATA;			p3=SOTBMPDATA;			p4=TPOINTDATA;			for (i=1; i<THINNINGWIDTH-1; i++) {				for (j=1; j<THINNINGHEIGHT-1; j++) {					if (p1[i][j]==0) {						p2[i][j]=0;						continue;					}					nbr=p1[i-1][j]|(p1[i-1][j+1]<<1)|(p1[i][j+1]<<2)|(p1[i+1][j+1]<<3)|(p1[i+1][j]<<4)|(p1[i+1][j-1]<<5)|(p1[i][j-1]<<6)|(p1[i-1][j-1]<<7);					k=p4[nbr];					if (k<2) {						p2[i][j]=(1-k);						continue;					}					if (i>1) {						nbn=p1[i-2][j]|(p1[i-2][j+1]<<1)|(p1[i-1][j+1]<<2)|(p1[i][j+1]<<3)|(p1[i][j]<<4)|(p1[i][j-1]<<5)|(p1[i-1][j-1]<<6)|(p1[i-2][j-1]<<7);					} else {						nbn=(p1[i-1][j+1]<<2)|(p1[i][j+1]<<3)|(p1[i][j]<<4)|(p1[i][j-1]<<5)|(p1[i-1][j-1]<<6);					}					if (j>1) {						nbw=p1[i-1][j-1]|(p1[i-1][j]<<1)|(p1[i][j]<<2)|(p1[i+1][j]<<3)|(p1[i+1][j-1]<<4)|(p1[i+1][j-2]<<5)|(p1[i][j-2]<<6)|(p1[i-1][j-2]<<7);					} else {						nbw=p1[i-1][j-1]|(p1[i-1][j]<<1)|(p1[i][j]<<2)|(p1[i+1][j]<<3)|(p1[i+1][j-1]<<4);					}					switch (k) {						case 2 :							if (p1[i-1][j]==0) {								p2[i][j]=1;								continue;							}							//North(p)不可删除							if (p4[nbn]==0) {								p2[i][j]=0;//删除 p								continue;							} else {								p2[i][j]=1;//保留 p								continue;							}							break;						case 3 :							if (p1[i][j-1]==0) {								p2[i][j]=1;								continue;							}							//West(p)不可删除							if (p4[nbw]==0) {								p2[i][j]=0;//删除 p								continue;							} else {								p2[i][j]=1;//保留 p								continue;							}							break;						case 4 :							if ((p1[i-1][j]==0)||(p1[i][j-1]==0)) {								p2[i][j]=1;								continue;							}							//North(p)&West(p)均不可删							if ((p4[nbn]==0)&&(p4[nbw]==0)) {								p2[i][j]=0;//删除 p								continue;							} else {								p2[i][j]=1;//保留 p								continue;							}							break;					}				}			}			changed=true;			count=2;			for (; changed; ) {				changed=false;				if ((count%2)==0) {					p2=FOTBMPDATA;//输入					p3=SOTBMPDATA;//输出				} else {					p2=SOTBMPDATA;//输入					p3=FOTBMPDATA;//输出				}				for (i=1; i<THINNINGWIDTH-1; i++) {					for (j=1; j<THINNINGHEIGHT-1; j++) {						if (p2[i][j]==0) {							p3[i][j]=0;							continue;						}						tmp1=p2[i-1][j]|(p2[i-1][j+1]<<1)|(p2[i][j+1]<<2)|(p2[i+1][j+1]<<3);						tmp2=p2[i+1][j]|(p2[i+1][j-1]<<1)|(p2[i][j-1]<<2)|(p2[i-1][j-1]<<3);						if ((count%2)==0) {							nbr=tmp2|(tmp1<<4);						} else {							nbr=tmp1|(tmp2<<4);						}						k=p4[nbr];						switch (k) {							case 0 ://不可删除								p3[i][j]=1;								break;							case 1 ://可以删除								p3[i][j]=0;								changed=true;								break;								//看看其北邻点是否可删,只有其北邻点不可删,当前点才可删							case 2 :								if (p2[i-1][j]==0) {									p3[i][j]=1;									continue;								}								if (i>1) {									tmp1=p2[i-2][j]|(p2[i-2][j+1]<<1)|(p2[i-1][j+1]<<2)|(p2[i][j+1]<<3);									tmp2=(p2[i][j])|(p2[i][j-1]<<1)|(p2[i-1][j-1]<<2)|(p2[i-2][j-1]<<3);								} else {									tmp1=(p1[i-1][j+1]<<2)|(p1[i][j+1]<<3);									tmp2=(p1[i][j])|(p1[i][j-1]<<1)|(p1[i-1][j-1]<<2);								}								if ((count%2)==0) {									nbn=tmp2|(tmp1<<4);								} else {									nbn=tmp1|(tmp2<<4);								}								//North(p)不可删								if (p4[nbn]==0) {									p3[i][j]=0;									changed=true;									break;								}								p3[i][j]=1;								break;								//看看其西邻点是否可删,只有其西邻点不可删,当前点才可删							case 3 :								if (p2[i][j-1]==0) {									p3[i][j]=1;									continue;								}								if (j>1) {									tmp1=p2[i-1][j-1]|(p2[i-1][j]<<1)|(p2[i][j]<<2)|(p2[i+1][j]<<3);									tmp2=(p2[i+1][j-1])|(p2[i+1][j-2]<<1)|(p2[i][j-2]<<2)|(p2[i-1][j-2]<<3);								} else {									tmp1=p2[i-1][j-1]|(p2[i-1][j]<<1)|(p2[i][j]<<2)|(p2[i+1][j]<<3);									tmp2=p2[i+1][j-1];								}								if ((count%2)==0) {									nbw=tmp2|(tmp1<<4);								} else {									nbw=tmp1|(tmp2<<4);								}								//West(p)不可删								if (p4[nbw]==0) {									p3[i][j]=0;									changed=true;									break;								}								p3[i][j]=1;								break;							case 4 :								if ((p2[i][j-1]==0)||(p2[i-1][j]==0)) {									p3[i][j]=1;									continue;								}								if (i>1) {									tmp1=p2[i-2][j]|(p2[i-2][j+1]<<1)|(p2[i-1][j+1]<<2)|(p2[i][j+1]<<3);									tmp2=(p2[i][j])|(p2[i][j-1]<<1)|(p2[i-1][j-1]<<2)|(p2[i-2][j-1]<<3);								} else {									tmp1=(p1[i-1][j+1]<<2)|(p1[i][j+1]<<3);									tmp2=(p1[i][j])|(p1[i][j-1]<<1)|(p1[i-1][j-1]<<2);								}								if ((count%2)==0) {									nbn=tmp2|(tmp1<<4);								} else {									nbn=tmp1|(tmp2<<4);								}								if (j>1) {									tmp1=p2[i-1][j-1]|(p2[i-1][j]<<1)|(p2[i][j]<<2)|(p2[i+1][j]<<3);									tmp2=(p2[i+1][j-1])|(p2[i+1][j-2]<<1)|(p2[i][j-2]<<2)|(p2[i-1][j-2]<<3);								} else {									tmp1=p2[i-1][j-1]|(p2[i-1][j]<<1)|(p2[i][j]<<2)|(p2[i+1][j]<<3);									tmp2=p2[i+1][j-1];								}								if ((count%2)==0) {									nbw=tmp2|(tmp1<<4);								} else {									nbw=tmp1|(tmp2<<4);								}								if ((p4[nbn]==0)&&(p4[nbw]==0)) {									p3[i][j]=0;									changed=true;									break;								}								p3[i][j]=1;								break;						}					}				}				count++;			}			for (i=0; i < THINNINGWIDTH;i++) {				for (j=0; j < THINNINGHEIGHT; j++) {					originalBitmap.setPixel(i,j,SOTBMPDATA[i][j] == 1?0x0:0xFFFFFF);				}			}			return (inset(originalBitmap,1));		}	}}