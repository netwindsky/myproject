package  org.lifeng.recognition.gdi{	import flash.display.BitmapData;	public class CharAPI {		//细化算法		//Hilditch细化算法（速度慢，源图像的要求少）		private static  var ERASETABLE:Array=new Array(0,0,1,1,0,0,1,1,1,1,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,0,1,1,1,1,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,1,1,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,0,1,1,1,1,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0);		public static function hilditch(originalBitmap:BitmapData):BitmapData {			//图像信息记录到数组			var THINNINGWIDTH:Number=originalBitmap.width;			var THINNINGHEIGHT:Number=originalBitmap.height;			var THINNINGCHECK:Number=0;			var THINNINGCOUNT:Number=0;			var g:Array=new Array(THINNINGWIDTH);			var f:Array=new Array(THINNINGWIDTH);			var n:Array=new Array(10);			for (var d:Number=0; d < THINNINGWIDTH; d++) {				g[d]=new Array(THINNINGHEIGHT);				f[d]=new Array(THINNINGHEIGHT);				for (var e:Number=0; e < THINNINGHEIGHT; e++) {					g[d][e]=f[d][e]=originalBitmap.getPixel(d,e) == 0?1:0;				}			}			//开始进行细化算法			do {				THINNINGCHECK=0;				for (var a:Number=0; a < THINNINGWIDTH; a++) {					for (var b:Number=0; b < THINNINGHEIGHT; b++) {						if (f[a][b] < 0) {							f[a][b]=0;						}						g[a][b]=f[a][b];					}				}				for (var i:Number=1; i < THINNINGWIDTH - 1; i++) {					for (var j:Number=1; j < THINNINGHEIGHT - 1; j++) {						var ti:Number=i - 1;						var tj:Number=j - 1;						var p11:Number=g[ti][tj];						var p12:Number=g[ti][j];						var p13:Number=g[ti][j + 1];						var p21:Number=g[i][tj];						var p22:Number=g[i][j];						var p23:Number=g[i][j + 1];						var p31:Number=g[i + 1][tj];						var p32:Number=g[i + 1][j];						var p33:Number=g[i + 1][j + 1];						if (p22 != 1||((p12 && p21 && p23 && p32) != 0)) {							continue;						}						if (p11 + p12 + p13 + p21 + p23 + p31 + p32 + p33 <= 1) {							f[i][j]=2;							continue;						}						n[4]=p11;						n[3]=p12;						n[2]=p13;						n[5]=p21;						n[1]=p23;						n[6]=p31;						n[7]=p32;						n[8]=p33;						n[9]=n[1];						THINNINGCOUNT=0;						for (var k:Number=1; k < 8; k=k+2) {							if (! n[k] && (n[k + 1] || n[k + 2])) {								THINNINGCOUNT++;							}						}						if (THINNINGCOUNT != 1) {							f[i][j]=2;							continue;						}						if (f[ti][j] == -1) {							f[ti][j]=0;							n[3]=0;							THINNINGCOUNT=0;							for (var q:Number=1; q < 8; q=q+2) {								if (! n[q] && (n[q + 1] || n[q + 2])) {									THINNINGCOUNT++;								}							}							if (THINNINGCOUNT != 1) {								f[ti][j]=-1;								continue;							}							f[ti][j]=-1;							n[3]=-1;						}						if (f[i][tj] != -1) {							f[i][j]=-1;							THINNINGCHECK=1;							continue;						}						f[i][tj]=0;						n[5]=0;						THINNINGCOUNT=0;						for (var p:Number=1; p < 8; p=p+2) {							if (! n[p] && (n[p + 1] || n[p + 2])) {								THINNINGCOUNT++;							}						}						if (THINNINGCOUNT == 1) {							f[i][tj]=-1;							f[i][j]=-1;							THINNINGCHECK=1;						} else {							f[i][tj]=-1;						}					}				}			} while (THINNINGCHECK);			//将细化后的位图返回			for (var xi:Number=0; xi < THINNINGWIDTH; xi++) {				for (var yi:Number=0; yi < THINNINGHEIGHT; yi++) {					originalBitmap.setPixel(xi,yi,g[xi][yi] == 0?0xFFFFFF:0x0);				}			}			return originalBitmap;		}		//////////////////////////////////////		//经过实验Rosenfeld算法更适合识别		//Rosenfeld细化算法（速度快，源图像有局限性）		//////////////////////////////////////		public static function rosenfeld(originalBitmap:BitmapData):BitmapData {			//图像信息记录到数组			var THINNINGWIDTH:Number=originalBitmap.width;			var THINNINGHEIGHT:Number=originalBitmap.height;			var THINNINGCHECK:Number=0;			var THINNINGCOUNT:Number=0;			var n:Array=new Array(10);			var g:Array=new Array(THINNINGWIDTH);			var f:Array=new Array(THINNINGWIDTH);			var a:Array = new Array(0, -1, 1, 0, 0);			var b:Array = new Array(0, 0, 0, 1, -1);			var ii,jj,nrnd, cond, n48, n26, n24, n46, n68, n82, n123, n345, n567, n781:Number=0;			for (var d:Number=0; d < THINNINGWIDTH; d++) {				g[d]=new Array(THINNINGHEIGHT);				f[d]=new Array(THINNINGHEIGHT);				for (var e:Number=0; e < THINNINGHEIGHT; e++) {					g[d][e]=f[d][e]=originalBitmap.getPixel(d,e) == 0?1:0;				}			}			do {				THINNINGCHECK = 0;				for (var k:Number=1; k<=4; k++) {					for (var i:Number=1; i<THINNINGWIDTH-1; i++) {						ii = i + a[k];						for (var j:Number=1; j<THINNINGHEIGHT-1; j++) {							var ti:Number=i - 1;							var tj:Number=j - 1;							if (!f[i][j]) {								continue;							}							jj = j + b[k];							if (f[ii][jj]) {								continue;							}							n[3] = f[ti][tj];							n[2] = f[ti][j];							n[1] = f[ti][j+1];							n[4] = f[i][tj];							n[8] = f[i][j+1];							n[5] = f[i+1][tj];							n[6] = f[i+1][j];							n[7] = f[i+1][j+1];							nrnd = n[1] + n[2] + n[3] + n[4] +n[5] + n[6] + n[7] + n[8];							if (nrnd<=1) {								continue;							}							cond = 0;							n48 = n[4] + n[8];							n26 = n[2] + n[6];							n24 = n[2] + n[4];							n46 = n[4] + n[6];							n68 = n[6] + n[8];							n82 = n[8] + n[2];							n123 = n[1] + n[2] + n[3];							n345 = n[3] + n[4] + n[5];							n567 = n[5] + n[6] + n[7];							n781 = n[7] + n[8] + n[1];							if (n[2]==1 && n48==0 && n567>0) {								if (!cond) {									continue;								}								g[i][j] = 0;								THINNINGCHECK = 1;								continue;							}							if (n[6]==1 && n48==0 && n123>0) {								if (!cond) {									continue;								}								g[i][j] = 0;								THINNINGCHECK = 1;								continue;							}							if (n[8]==1 && n26==0 && n345>0) {								if (!cond) {									continue;								}								g[i][j] = 0;								THINNINGCHECK = 1;								continue;							}							if (n[4]==1 && n26==0 && n781>0) {								if (!cond) {									continue;								}								g[i][j] = 0;								THINNINGCHECK = 1;								continue;							}							if (n[5]==1 && n46==0) {								if (!cond) {									continue;								}								g[i][j] = 0;								THINNINGCHECK = 1;								continue;							}							if (n[7]==1 && n68==0) {								if (!cond) {									continue;								}								g[i][j] = 0;								THINNINGCHECK = 1;								continue;							}							if (n[1]==1 && n82==0) {								if (!cond) {									continue;								}								g[i][j] = 0;								THINNINGCHECK = 1;								continue;							}							if (n[3]==1 && n24==0) {								if (!cond) {									continue;								}								g[i][j] = 0;								THINNINGCHECK = 1;								continue;							}							cond = 1;							if (!cond) {								continue;							}							g[i][j] = 0;							THINNINGCHECK = 1;						}					}					for (i=0; i<THINNINGWIDTH; i++) {						for (j=0; j<THINNINGHEIGHT; j++) {							f[i][j] = g[i][j];						}					}				}			} while (THINNINGCHECK);			//将细化后的位图返回			for (var xi:Number=0; xi < THINNINGWIDTH; xi++) {				for (var yi:Number=0; yi < THINNINGHEIGHT; yi++) {					originalBitmap.setPixel(xi,yi,g[xi][yi] == 0?0xFFFFFF:0x0);				}			}			return originalBitmap;		}		//基于索引表的细化算法		//生成的骨架是严格的 1 象素宽		public static function thinning(originalBitmap:BitmapData):BitmapData {			var i,j,k:Number=0;			var changed:Boolean;			var count:Number=0;			var THINNINGWIDTH:Number=originalBitmap.width;			var THINNINGHEIGHT:Number=originalBitmap.height;			var nbr,tmp1,tmp2,nbn,nbw:Number;			var ORIBMPDATA:Array=new Array(THINNINGWIDTH);			var FOTBMPDATA:Array=new Array(THINNINGWIDTH);			var SOTBMPDATA:Array=new Array(THINNINGWIDTH);			var TPOINTDATA:Array=new Array(256);			//指针			for (i=0; i < THINNINGWIDTH; i++) {				ORIBMPDATA[i]=new Array(THINNINGHEIGHT);				FOTBMPDATA[i]=new Array(THINNINGHEIGHT);				SOTBMPDATA[i]=new Array(THINNINGHEIGHT);				for (var j:Number=0; j < THINNINGHEIGHT; j++) {					ORIBMPDATA[i][j]=originalBitmap.getPixel(d,e) == 0?1:0;					FOTBMPDATA[i][j]=SOTBMPDATA[i][j]=0;				}			}			var p1,p2,p3,p4:Array;			p1=ORIBMPDATA;			p2=FOTBMPDATA;			p3=SOTBMPDATA;			p4=TPOINTDATA;			for (i=1; i<THINNINGWIDTH-1; i++) {				for (j=1; j<THINNINGHEIGHT-1; j++) {					if (p1[i][j]==0) {						p2[i][j]=0;						continue;					}					nbr=p1[i-1][j]|(p1[i-1][j+1]<<1)|(p1[i][j+1]<<2)|(p1[i+1][j+1]<<3)|(p1[i+1][j]<<4)|(p1[i+1][j-1]<<5)|(p1[i][j-1]<<6)|(p1[i-1][j-1]<<7);					k=p4[nbr];					if (k<2) {						p2[i][j]=(1-k);						continue;					}					if (i>1) {						nbn=p1[i-2][j]|(p1[i-2][j+1]<<1)|(p1[i-1][j+1]<<2)|(p1[i][j+1]<<3)|(p1[i][j]<<4)|(p1[i][j-1]<<5)|(p1[i-1][j-1]<<6)|(p1[i-2][j-1]<<7);					} else {						nbn=(p1[i-1][j+1]<<2)|(p1[i][j+1]<<3)|(p1[i][j]<<4)|(p1[i][j-1]<<5)|(p1[i-1][j-1]<<6);					}					if (j>1) {						nbw=p1[i-1][j-1]|(p1[i-1][j]<<1)|(p1[i][j]<<2)|(p1[i+1][j]<<3)|(p1[i+1][j-1]<<4)|(p1[i+1][j-2]<<5)|(p1[i][j-2]<<6)|(p1[i-1][j-2]<<7);					} else {						nbw=p1[i-1][j-1]|(p1[i-1][j]<<1)|(p1[i][j]<<2)|(p1[i+1][j]<<3)|(p1[i+1][j-1]<<4);					}					switch (k) {						case 2 :							if (p1[i-1][j]==0) {								p2[i][j]=1;								continue;							}							//North(p)不可删除							if (p4[nbn]==0) {								p2[i][j]=0;//删除 p								continue;							} else {								p2[i][j]=1;//保留 p								continue;							}							break;						case 3 :							if (p1[i][j-1]==0) {								p2[i][j]=1;								continue;							}							//West(p)不可删除							if (p4[nbw]==0) {								p2[i][j]=0;//删除 p								continue;							} else {								p2[i][j]=1;//保留 p								continue;							}							break;						case 4 :							if ((p1[i-1][j]==0)||(p1[i][j-1]==0)) {								p2[i][j]=1;								continue;							}							//North(p)&West(p)均不可删							if ((p4[nbn]==0)&&(p4[nbw]==0)) {								p2[i][j]=0;//删除 p								continue;							} else {								p2[i][j]=1;//保留 p								continue;							}							break;						default :							ASSERT(false);					}				}			}			changed=true;			count=2;			for (; changed; ) {				changed=false;				if ((count%2)==0) {					p2=FOTBMPDATA;//输入					p3=SOTBMPDATA;//输出				} else {					p2=SOTBMPDATA;//输入					p3=FOTBMPDATA;//输出				}				for (i=1; i<THINNINGWIDTH-1; i++) {					for (j=1; j<THINNINGHEIGHT-1; j++) {						if (p2[i][j]==0) {							p3[i][j]=0;							continue;						}						tmp1=p2[i-1][j]|(p2[i-1][j+1]<<1)|(p2[i][j+1]<<2)|(p2[i+1][j+1]<<3);						tmp2=p2[i+1][j]|(p2[i+1][j-1]<<1)|(p2[i][j-1]<<2)|(p2[i-1][j-1]<<3);						if ((count%2)==0) {							nbr=tmp2|(tmp1<<4);						} else {							nbr=tmp1|(tmp2<<4);						}						k=p4[nbr];						switch (k) {							case 0 ://不可删除								p3[i][j]=1;								break;							case 1 ://可以删除								p3[i][j]=0;								changed=true;								break;								//看看其北邻点是否可删,只有其北邻点不可删,当前点才可删							case 2 :								if (p2[i-1][j]==0) {									p3[i][j]=1;									continue;								}								//ASSERT(p2[i-1][j]==1);								if (i>1) {									tmp1=p2[i-2][j]|(p2[i-2][j+1]<<1)|(p2[i-1][j+1]<<2)|(p2[i][j+1]<<3);									tmp2=(p2[i][j])|(p2[i][j-1]<<1)|(p2[i-1][j-1]<<2)|(p2[i-2][j-1]<<3);								} else {									tmp1=(p1[i-1][j+1]<<2)|(p1[i][j+1]<<3);									tmp2=(p1[i][j])|(p1[i][j-1]<<1)|(p1[i-1][j-1]<<2);								}								if ((count%2)==0) {									nbn=tmp2|(tmp1<<4);								} else {									nbn=tmp1|(tmp2<<4);								}								//North(p)不可删								if (p4[nbn]==0) {									p3[i][j]=0;									changed=true;									break;								}								p3[i][j]=1;								break;								//看看其西邻点是否可删,只有其西邻点不可删,当前点才可删							case 3 :								if (p2[i][j-1]==0) {									p3[i][j]=1;									continue;								}								//ASSERT(p2[i][j-1]==1);								if (j>1) {									tmp1=p2[i-1][j-1]|(p2[i-1][j]<<1)|(p2[i][j]<<2)|(p2[i+1][j]<<3);									tmp2=(p2[i+1][j-1])|(p2[i+1][j-2]<<1)|(p2[i][j-2]<<2)|(p2[i-1][j-2]<<3);								} else {									tmp1=p2[i-1][j-1]|(p2[i-1][j]<<1)|(p2[i][j]<<2)|(p2[i+1][j]<<3);									tmp2=p2[i+1][j-1];								}								if ((count%2)==0) {									nbw=tmp2|(tmp1<<4);								} else {									nbw=tmp1|(tmp2<<4);								}								//West(p)不可删								if (p4[nbw]==0) {									p3[i][j]=0;									changed=true;									break;								}								p3[i][j]=1;								break;							case 4 :								if ((p2[i][j-1]==0)||(p2[i-1][j]==0)) {									p3[i][j]=1;									continue;								}								if (i>1) {									tmp1=p2[i-2][j]|(p2[i-2][j+1]<<1)|(p2[i-1][j+1]<<2)|(p2[i][j+1]<<3);									tmp2=(p2[i][j])|(p2[i][j-1]<<1)|(p2[i-1][j-1]<<2)|(p2[i-2][j-1]<<3);								} else {									tmp1=(p1[i-1][j+1]<<2)|(p1[i][j+1]<<3);									tmp2=(p1[i][j])|(p1[i][j-1]<<1)|(p1[i-1][j-1]<<2);								}								if ((count%2)==0) {									nbn=tmp2|(tmp1<<4);								} else {									nbn=tmp1|(tmp2<<4);								}								if (j>1) {									tmp1=p2[i-1][j-1]|(p2[i-1][j]<<1)|(p2[i][j]<<2)|(p2[i+1][j]<<3);									tmp2=(p2[i+1][j-1])|(p2[i+1][j-2]<<1)|(p2[i][j-2]<<2)|(p2[i-1][j-2]<<3);								} else {									tmp1=p2[i-1][j-1]|(p2[i-1][j]<<1)|(p2[i][j]<<2)|(p2[i+1][j]<<3);									tmp2=p2[i+1][j-1];								}								if ((count%2)==0) {									nbw=tmp2|(tmp1<<4);								} else {									nbw=tmp1|(tmp2<<4);								}								if ((p4[nbn]==0)&&(p4[nbw]==0)) {									p3[i][j]=0;									changed=true;									break;								}								p3[i][j]=1;								break;						}					}				}				count++;			}			for (i:Number=0; i < THINNINGWIDTH;i++) {				for (var j:Number=0; j < THINNINGHEIGHT; j++) {					originalBitmap.setPixel(i,j,SOTBMPDATA[i][j] == 1?0x0:0xFFFFFF);				}			}		}	}}